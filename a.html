<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="/面试题/js/typeof&&instanceof.js"></script>
</head>

<body>


</body>
<script>
    function Person() {
        this.star = '天蝎座'
    }

    Person.prototype.star = '天蝎'
    let person = new Person()
    // 当前实例的原型链，是指向当前实例的构造函数的原型
    console.log(person.__proto__ === Person.prototype)//true
    delete person.star
    // console.log(person.aaa)
    console.log(Person.prototype.__proto__ === Object.prototype)//true

    console.log(Object.prototype.__proto__) // 我们认为就找到头了null
    console.log(Person.prototype.constructor === Person)//true

    // 比较特殊的：Function Object 这两个身上都有__proto__ 和 prototype 

    console.log(Function.__proto__ === Function.prototype)//true
    console.log(Object.__proto__ === Function.prototype)//true
    console.log(Function.__proto__ === Object.__proto__)//true

    function Person() {
        this.star = '天蝎座'
    }

    Person.prototype.star = '天蝎'
    let person = new Person()
    // 判断当前属性是否在实例上和是否在原型上
    console.log(person.hasOwnProperty('star'))//true
    console.log('star' in person)//true

    // 引入了一个新方法：Object.create()
    // 可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数

    const arrayProto = Array.prototype
    const protoMethods = Object.create(arrayProto)
    // console.log(protoMethods)
    protoMethods['push'] = function () {
        console.log('新改写的push方法')
    }
    let arr = [1, 2, 3]
    arr.__proto__ = protoMethods
    arr.push(4)
    console.log(arr)
</script>

</html>